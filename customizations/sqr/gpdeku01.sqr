!***********************************************************************
!  GPDEKU01:   KUG Refund List                                         *
!***********************************************************************
!                                                                      *
!                                                                      *
!                                                                      *
! This software and related documentation are provided under a         *
! license agreement containing restrictions on use and                 *
! disclosure and are protected by intellectual property                *
! laws. Except as expressly permitted in your license agreement        *
! or allowed by law, you may not use, copy, reproduce,                 *
! translate, broadcast, modify, license, transmit, distribute,         *
! exhibit, perform, publish or display any part, in any form or        *
! by any means. Reverse engineering, disassembly, or                   *
! decompilation of this software, unless required by law for           *
! interoperability, is prohibited.                                     *
! The information contained herein is subject to change without        *
! notice and is not warranted to be error-free. If you find any        *
! errors, please report them to us in writing.                         *
!                                                                      *
!
! Copyright (C) 1988, 2014, Oracle and/or its affiliates.              *
! All Rights Reserved.                                                 *
!----------------------------------------------------------------------
!
!          $Date:  2014/07/07:10:31:57                                 !
!       $Release:  HR92                                                !
!      $Revision:  108                                                 !
!                                                                      *
!***********************************************************************
! changes:
! whu06-881kug2 created new report
! wdu06-881kug3 only print rows with amounts <> 0
! wdu06-881b10 added process instance for parallel execution of gpdeku01 and gpdeku02
! wdu06-890b5 label changes Soll/Ist
! adj09-900b10 Layout of list for short time working (KUG-Listen)
! adj09-900b10 Refund for the Employer Social Insurance Contributions
! adj10-89updD Matrix code
! byarn11-90updB New requirements for Short-Time-Payment Report GPDEKU01 (KUG)
! byarn14-PUM8 Matrix code
!
!#define gpdeversionstamp '===FUNCTIONAL UPDATE STAMP: 20060516 wdu06-890b5==='
!#define gpdeversionstamp '===FUNCTIONAL UPDATE STAMP: 20090317 adj09-8900b17'
!#define gpdeversionstamp '===FUNCTIONAL UPDATE STAMP: 20090520 adj10-89updD'
!#define gpdeversionstamp '===FUNCTIONAL UPDATE STAMP: 20110111 byarn-90updD'
#define gpdeversionstamp '===FUNCTIONAL UPDATE STAMP: 20140627 byarn-PUM8'
! #define debug
!
!
!
#include 'setenv.sqc' !set environment


!*****************************************************************************
begin-PROGRAM
  do Init-DateTime
  do Init-Number
  do Get-Current-DateTime
  do Init-Report
  do Process-Main
  do Stdapi-Term
end-PROGRAM


begin-heading 10  FOR-REPORTS   =  (report2)
!
! heading for the report
!
    alter-printer
    font= 4
    point-size = 7.2

    ! notice: if we can have differing values for Pay_Entity, then we must use the
    !         last-row-version as an input here!
    do Get-Payentity-Data($Ctl_PayEntity, $Ctl_Curr_Pay_End_DT, $hdr_abr_Payentity_name,
      $hdr_abr_Payentity_street,$hdr_abr_Payentity_street2,$hdr_abr_Payentity_street3,
      $hdr_PoBox,$hdr_abr_Payentity_zip_city,$Nation,$Post,$Cit)

    !do HeadingInfos
    do CX_StandardHeaderBox

    ! switch back the font to body text.
    alter-printer
    font= 3
    point-size =13
end-heading


begin-procedure bodybox
    alter-printer
    font= 4
    point-size =13

    let #BoxLine1 = #currLineV        !14
    let #BoxLine2 = #BoxLine1 +1
    let #BoxLine3 = #BoxLine2 +1
    let #BoxLine4 = #BoxLine3 +1
    let #BoxLine5 = #BoxLine4 +1
    let #BoxLine6 = #BoxLine5 +1
    let #BoxLine7 = #BoxLine6 +1
    let #BoxLine8 = #BoxLine7 +1

    graphic (#BoxLine4,1,184) box 5 1 12
    graphic (#BoxLine3,#vline1,5) vert-line 1
    graphic (#BoxLine3,#vline2,5) vert-line 1
    graphic (#BoxLine3,#vline5,5) vert-line 1
    graphic (#BoxLine3,#vline6,5) vert-line 1
    graphic (#BoxLine3,#vline7,5) vert-line 1        ! after Stkl
    graphic (#BoxLine3,#vline8,5) vert-line 1
    graphic (#BoxLine3,#vline9,5) vert-line 1
    graphic (#BoxLine3,#vline10,5) vert-line 1
    graphic (#BoxLine3,#vline11,5) vert-line 1

    print 'Lfd.'     (#BoxLine4,2)  bold
    print 'Nr.'      (#BoxLine5,2)  bold

    print 'Name, Vorname'        (#BoxLine4,10) bold
    print 'Versicherungsnummer'  (#BoxLine5,10) bold

    print '    Umfang des Arbeitsausfalls'       (#BoxLine4,46) bold
    print ' (Anzahl der Kug-Ausfallstunden)'      (#BoxLine5,46) bold
    print '                    '                   (#BoxLine6,46) bold
    print 'ggf. Anzahl anderer Sozialleistungs-'   (#BoxLine7,46) bold
    print '  stunden sowie Insgesamtstunden'       (#BoxLine8,46) bold

    print 'Sollentgelt'        (#BoxLine4,84) bold
    print '(ungerundet)'       (#BoxLine5,83) bold

    print 'Istentgelt'         (#BoxLine4,103) bold
    print '(ungerundet)'       (#BoxLine5,102) bold

    print 'L.gruppe'           (#BoxLine4,118) bold
    print '/ L.satz'            (#BoxLine5,118) bold
!    print 'Leistun-'           (#BoxLine6,118) bold
!    print 'gssatz'             (#BoxLine7,119) bold

    print 'Rechnerischer'       (#BoxLine4,128) bold
    print 'Leistungssatz'       (#BoxLine5,128) bold
    print 'Sollentgelt'         (#BoxLine6,128) bold

! wdu06-890b5 label changes Soll/Ist
    print 'Rechnerischer'       (#BoxLine4,142) bold
    print 'Leistungssatz'       (#BoxLine5,142) bold
    print 'Istentgelt'          (#BoxLine6,142) bold

    print 'Durch-'             (#BoxLine4,156) bold
    print 'schnittl.'           (#BoxLine5,156) bold
    print 'L.satz pro'          (#BoxLine6,156) bold
    print 'Stunde'              (#BoxLine7,156) bold

    print 'Auszuzahlendes'      (#BoxLine4,167) bold
    print 'Kurzarbeitergeld'    (#BoxLine5,167) bold

end-procedure
!**************************************************************************





begin-procedure Init-Report
    do Stdapi-Init
    do Get-ReqParam

    ! wdu jw2005 modified 890 file handling
    let $outputdir = $sqr-report

    do GetFileExtension($RQ.OUTDESTFORMAT, $FileExtension)
    do GetOutputDir($RUNLOCATION,$OUTDESTTYPE,$OUTDEST,$outputdir)

    #debug show 'outputdir: ' $outputdir
    #debug show 'fileextension: ' $FileExtension

    ! wdu-04b4 changed for customer process:
    ! begin runcontrol data
    ! If no oprid or runcontrol was passed on the commandline, then ask for it.
    ! After that, fetch functional data from the runcontrol.
    ! The input of functional values is no longer supported.
    if $prcs_process_instance = ''
        input $PRCS_OPRID 'OPRID '
        input $PRCS_RUN_CNTL_ID 'RUNCONTROL '
        ! wdu05b6: 'input $outputdir' requested by customer
        input $outputdir
        do Get-Report-Parameters
        ! always override language settings
        let $LANGUAGE_CD = 'GER'
        let $CURR_LANGUAGE_CD = 'GER'
    else
        do Get-Report-Parameters
    end-if
    ! end runcontrol data


    move 'GPDEKU01' to $ReportID
    do Init_Report_Translation ($ReportID, $language_cd)
    do Append_Report_Translation ('GPDEGLOB')
    do Report-Translation
    !let $ReportTitle = $TITLE1 || ' ' || rtrim($Ctl_Year,' ')
    
!adj10- get absolute path of the image file
  let #pos  = instr($sqr-program,'gpdeku01',0)
  let #pos  = #pos - 1
  let $path = substr($sqr-program,1,#pos)
  let $FileDir = $path || 'matrixcode_kug_108.gif'

  #ifdef MVS
     let #pos  = instr($sqr-program,'Matrixcode_KUG_108',0)
     let #pos  = #pos - 1
     let $path = substr($sqr-program,1,#pos)
     let $FileDir = $path || 'matrixcode_kug_108)'
  #end-if

  #ifdef OS390
     let #pos  = instr($sqr-program,'matrixcode_kug_108',0)
     let #pos  = #pos - 1
     let $path = substr($sqr-program,1,#pos)
     let $FileDir = $path || 'matrixcode_kug_108)'
  #end-if

  #ifdef OS400
     let #pos  = instr($sqr-program,'matrixcode_kug_108',0)
     let #pos  = #pos - 1
     let $path = substr($sqr-program,1,#pos)
     let $FileDir = $path || 'matrixcode_kug_108)'
  #end-if

  #ifdef UNIX
     let $FileDir = $path || 'matrixcode_kug_108.gif'
  #end-if
  #debug show 'SQR Directory:-' $FileDir    
    
end-procedure
!*****************************************************************************




begin-setup
  #include 'setupdb.sqc'
  declare-layout report2
    paper-size    = (19,11.69)
    orientation   = LANDSCAPE
    line-height   = 14
    max-columns   = 188
    left-margin   = .4
    bottom-margin = .15
    top-margin    = 0.4
  end-declare
  declare-report report2
    layout = report2
  end-declare
end-setup
!*****************************************************************************




begin-procedure Process-Main

    show {gpdeversionstamp}
    ! wdu05-881b8: backport of MVS changes from 891
    if $prcs_process_instance <> ''
        ! wdu89mp1: filename too long for mvs, removed process-instance in name for this
#ifdef MVS
        let $SqrName = 'GPDEKU01'
#else
        let $SqrName = 'GPDEKU01_' || $prcs_process_instance
#endif
    else
        let $SqrName = 'GPDEKU01'
    end-if

    ! process instance for temp tables (preparation for new logic)
    let #ReportProcessInstance = 0

    do Get_Type_Options

    !
    ! employee independent inits
    !
    let $MinusNull = '-0' || $SDecimal || '00'
    let $PlusNull = '0' || $SDecimal || '00'

    do Get_VersionNr

    ! start the reporting
    do PrepareRowData
    do KugReport
end-procedure







!***********************************************************************!
! Report                                                                !
!***********************************************************************!
begin-procedure KugReport
! main procedure for the printing of the list
!
! expected runcontrol parameters:
! $Ctl_PayEntity
! $Ctl_Curr_Pay_End_DT      =calculated in
!
    ! init vars for vertical lines in boxes
    let #vline0    = 1
    let #vline1    = 9
    let #vline2    = 45
    let #vline4    = 62         ! after hours
    let #vline5    = 78
    let #vline6    = 98
    let #vline7    = 117         ! after istentgelt
    let #vline8    = 127
    let #vline9    = 141
    let #vline10   = 155
    let #vline11   = 165  !168
    ! associated text positions
    let #txtpos0 = #vline0 + 1
    let #txtpos1 = #vline1 + 1
    let #txtpos2 = #vline2 + 1
    let #txtpos4 = #vline4 + 1
    let #txtpos5 = #vline5 + 1
    let #txtpos6 = #vline6 + 1
    let #txtpos7 = #vline7 + 1
    let #txtpos8 = #vline8 + 1
    let #txtpos9 = #vline9 + 1
    let #txtpos10 = #vline10 + 1
    let #txtpos11 = #vline11 + 1

    ! get headerstring which only depends on $Ctl_Curr_Pay_End_DT
    do getHeaderDateString

    ! override the language for country specific statutory report
    let $curr_language_cd = 'GER'
    use-report report2
    let $reportdir = $outputdir || $SqrName || $FileExtension || '{FILESUFFIX}'
    new-report $reportdir
    !redundant?
    use-report report2
    alter-printer
    font= 4
    point-size =13
    do Print_Employee_Data
    do Print_Employee_Data_Retro
end-procedure
!tax update 2011
begin-procedure Get_TaxFactor_data($Emplid,#Empl_Rcd_Num,$prd_end_date,$EffYear,:$GPDE_TX_FACTOR)

 let $prd_bgn_date = ''
 let $GPDE_TX_FACTOR = '' 
 let $taxyear = ''
 let $EndYear = ''
 
begin-select Distinct 
RP.PRD_BGN_DT
RP.PRD_END_DT 
    
     let $prd_bgn_date = &RP.PRD_BGN_DT    

from PS_GPDE_RP_0001 RP
where RP.EMPLID = $Emplid
AND RP.EMPL_RCD = #Empl_Rcd_Num
AND RP.PRD_END_DT = $prd_end_date   
     
end-select

do ConvertToComponents($prd_end_date, $taxyear, $txmnth, $txDay)
  
begin-select distinct 
TX.EFFDT 
TX.GPDE_TX_INC_TX_CLS 
TX.GPDE_TX_FACTOR
      
      if $EffYear >= '2011' and &TX.GPDE_TX_INC_TX_CLS = '4'         
        !Byar11: tax update 2011        
        let $GPDE_TX_FACTOR = &TX.GPDE_TX_FACTOR        
      end-if
    
 from PS_GPDE_TX_DATA TX
 where TX.EMPLID = $Emplid
 AND TX.EMPL_RCD = #Empl_Rcd_Num
 AND TX.EFFDT = (select max(T.effdt) from PS_GPDE_TX_DATA T
 where T.EMPLID = $Emplid 
 and T.EMPL_RCD = #Empl_Rcd_Num 
 )
     
end-select

end-procedure

begin-procedure Get_TaxFactor_retro($Emplid,#Empl_Rcd_Num,$prd_end_date, $cpay_end_date,$EffYear,$RowType,:$GPDE_TX_FACTOR)
 
let $prd_bgn_date = ''
let $GPDE_TX_FACTOR = '' 
let $taxyear = ''
let $EndYear = ''

begin-select distinct 
RP.prd_end_dt
RP.GPDE_TX_INC_TX_CLS
RP.GPDE_TX_FACTOR
RP.gpde_al_cpay_enddt 
   
   if $EffYear >= '2011' and &RP.GPDE_TX_INC_TX_CLS = '4'         
        !Byar10: tax update 2011        
        let $GPDE_TX_FACTOR = &RP.GPDE_TX_FACTOR
   else
     let $GPDE_TX_FACTOR =''
   end-if
   
from PS_GPDE_RP_EL_DBEN RP
where RP.EMPLID = $Emplid 
      AND RP.EMPL_RCD = #Empl_Rcd_Num
      AND RP.prd_end_dt = $prd_end_date 
      AND RP.seg_end_dt = RP.prd_end_dt 
      AND (RP.gpde_al_cpay_enddt = RP.prd_end_dt or RP.gpde_al_cpay_enddt = $cpay_end_date)
      AND RP.GPDE_TX_INC_TX_CLS = '4'
      AND RP.prd_end_dt = (select KU.prd_end_dt from PS_GPDE_RP_KU1_WRK KU 
                           where KU.emplid = RP.emplid and KU.seg_end_dt = RP.seg_end_dt 
                           and KU.gpde_al_cpay_enddt = RP.gpde_al_cpay_enddt 
                           and KU.gpde_bl_type= $RowType)
                            
end-select

end-procedure

begin-procedure Print_Employee_Data_Retro
! main select here
    let #counter = 1        ! row counter per group
    let #currLineN = 0
    let #currLineV = 0
    let #TempCol = 1
    let #i = 1

    ! BREAK detection
    let $lastPeriodEnd = ' '
    let $lastStammNummer = '-none-'
    let $EffYear = ''
    let $EndYear = ''
    let #makePageBreak = 0
    ! Sums
    let #pageSumKug = 0
    let #EntsolSum = 0
    let #EntistSum = 0
    !Target Region
    let #TgtReg = 9
    let #lastTgtReg  = 99
    ! Refund KUG SI Contribution
    let #Refund = 0
    let #lastRefund = 99
    ! Events
    let #eventStammNummer = 0           ! Change of Stammnummer coming up
    let #eventFirstRow = 1              ! First row of the page
    ! Print Sum Per Split
    let #SplitSum = 0
    let $QualiElg = ' '
    let $lastQualiElg = ' '
    Let $PrevDate = ' '
Begin-Select
K2.EMPLID
K2.CAL_RUN_ID
K2.EMPL_RCD
K2.GP_PAYGROUP
K2.CAL_ID
K2.ORIG_CAL_RUN_ID
K2.RSLT_SEG_NUM
K2.SEG_END_DT
K2.SLICE_END_DT
K2.GPDE_BL_TYPE
K2.PAY_ENTITY
K2.PRD_END_DT
K2.GPDE_AL_CPAY_ENDDT
K2.GPDE_KU_ID_NUM
K2.BGN_DT
K2.END_DT
K2.GPDE_DV_RVNR
K2.GPDE_KU_HKUGSUM
K2.GPDE_KU_HKGKK
K2.GPDE_KU_HKUGINS
K2.GPDE_KU_ENTSOLL
K2.GPDE_KU_ENTIST
K2.GPDE_TX_INC_TX_CLS
K2.GPDE_KU_BEN_GRP
K2.GPDE_KU_BEN_STP
K2.GPDE_KU_LSTSOLL
K2.GPDE_KU_LSTIST
K2.GPDE_KU_AVGLST
K2.GPDE_KU_KUGAMT
K2.GPDE_KU_NEBEN
K2.GPDE_KU_KUGKKAMT
NM2.NAME
NM2.LAST_NAME
NM2.FIRST_NAME
K2.GPDE_KU_QUALI_ELIG
K2.GPDE_KU_TARGET_REG
K2.GPDE_KU_SI_REFUND

    let #TgtReg = &K2.GPDE_KU_TARGET_REG
    let #Refund = &K2.GPDE_KU_SI_REFUND
    let $QualiElg = rtrim(&K2.GPDE_KU_QUALI_ELIG,' ')

    ! --- informational fields ---
    ! note: the #counter should only incremented when we really print a line

    let $RowType = &K2.GPDE_BL_TYPE
! Split the report on change in A.KUG_Stammnummer B. Refund  & C. TgtReg
    let $KUG_Stammnummer = rtrim(&K2.GPDE_KU_ID_NUM,' ')
    if ( $KUG_Stammnummer <> $lastStammNummer )
        #debug show 'force begin of a new page (KUG_Stammnummer)'
        let #makePageBreak = 1
        let #eventStammNummer = 1
        let #SplitSum = 1
        let #counter = 0
    end-if
    if  #lastRefund <> #Refund
        let #makePageBreak = 1
        let #eventStammNummer = 1
        let #SplitSum = 1
        let #counter = 0
    end-if
    if  #lastTgtReg <> #TgtReg
         let #makePageBreak = 1
         let #eventStammNummer = 1
         let #SplitSum = 1
         let #counter = 0
    end-if
    if  $lastQualiElg <> $QualiElg and $lastQualiElg <> ' '
        let #makePageBreak = 1
        let #SplitSum = 1
        let #eventStammNummer = 0
        let #counter = 0
     end-if

    let $K1.GPDE_DV_RVNR = &K2.GPDE_DV_RVNR
    let $Emplid = rtrim(&K2.EMPLID,' ')
    let $EmplRcd = &K2.EMPL_RCD

    let $K1.PRD_END_DT = &K2.PRD_END_DT
!    if ( $K1.PRD_END_DT <> $lastPeriodEnd )
!        #debug show 'force begin of a new page (K1.PRD_END_DT)'
!        let #makePageBreak = 1
!    end-if

    ! parameter for row-date output
    !--let $SegmentDate = &K1.GPDE_AL_CPAY_ENDDT
    let $SegmentDate = &K2.PRD_END_DT
    do MakeRowDate      ! returns: $RowDateText  in format: MM.YY neu/alt

   !-----------------------------------------------------------------------
    do ConvertToComponents($Ctl_Curr_Pay_End_DT, $EffYear, $EffMth, $EffDay)    
    !If there is a retro then fetch data from PS_GPDE_RP_EL_DBEN
     if $RowType = 'B'
       do Get_TaxFactor_retro($Emplid,&K2.EMPL_RCD,&K2.PRD_END_DT, &K2.GPDE_AL_CPAY_ENDDT,$EffYear,$RowType,$gpde_tx_factor)
     else
       do Get_TaxFactor_retro($Emplid,&K2.EMPL_RCD,$K1.PRD_END_DT, $Ctl_Curr_Pay_End_DT,$EffYear,$RowType,$gpde_tx_factor)
     end-if     
    
    !-----------------------------------------------------------------------

    #debug show 'Progressinfo: ' $Emplid ' / ' $KUG_Stammnummer ' / ' $lastStammNummer ' - ' $hdr_KUG_Stammnummer

    let $NM1.NAME = rtrim(&NM2.NAME,' ')

! uncomment this if emplid should be printed
! #if debug
!    ! debug: add Emplid
!    let $NM1.NAME = $NM1.NAME || ',' || $Emplid
! #endif

    ! -- when name is printed in regular font we need to truncate at length 28
    if length($NM1.NAME) > 41
        let $NM1.NAME = substr($NM1.NAME,1,41)
    end-if

    let $K1.GPDE_TX_INC_TX_CLS = &K2.GPDE_TX_INC_TX_CLS
    let $K1.GPDE_KU_BEN_STP = &K2.GPDE_KU_BEN_STP
    let $K1.GPDE_KU_BEN_GRP = &K2.GPDE_KU_BEN_GRP

    ! --- numeric values ---
    ! --- HOURS ---
    ! notice, that we need 4 digits because we can have negative hours in retro
    let #K1.GPDE_KU_HKUGSUM = &K2.GPDE_KU_HKUGSUM
    do Format-Number(#K1.GPDE_KU_HKUGSUM,$K1.GPDE_KU_HKUGSUM,'B999.99')
    let #K1.GPDE_KU_HKGKK = &K2.GPDE_KU_HKGKK
    do Format-Number(#K1.GPDE_KU_HKGKK,$K1.GPDE_KU_HKGKK,'B999.99')
    let #K1.GPDE_KU_HKUGINS = &K2.GPDE_KU_HKUGINS
    do Format-Number(#K1.GPDE_KU_HKUGINS,$K1.GPDE_KU_HKUGINS,'B999.99')

    let #K1.GPDE_KU_ENTSOLL = &K2.GPDE_KU_ENTSOLL
    do Format-Number(#K1.GPDE_KU_ENTSOLL,$K1.GPDE_KU_ENTSOLL,'B99,999.99')
    let #K1.GPDE_KU_ENTIST = &K2.GPDE_KU_ENTIST
    do Format-Number(#K1.GPDE_KU_ENTIST,$K1.GPDE_KU_ENTIST,'B99,999.99')

    let #K1.GPDE_KU_LSTSOLL = &K2.GPDE_KU_LSTSOLL
    do Format-Number(#K1.GPDE_KU_LSTSOLL,$K1.GPDE_KU_LSTSOLL,'B99,999.99')
    let #K1.GPDE_KU_LSTIST = &K2.GPDE_KU_LSTIST
    do Format-Number(#K1.GPDE_KU_LSTIST,$K1.GPDE_KU_LSTIST,'B99,999.99')

    let #K1.GPDE_KU_AVGLST = &K2.GPDE_KU_AVGLST
    do Format-Number(#K1.GPDE_KU_AVGLST,$K1.GPDE_KU_AVGLST,'B999.99')

    let #K1.GPDE_KU_KUGAMT = &K2.GPDE_KU_KUGAMT
    do Format-Number(#K1.GPDE_KU_KUGAMT,$K1.GPDE_KU_KUGAMT,'B99,999.99')
    let #K1.GPDE_KU_KUGKKAMT = &K2.GPDE_KU_KUGKKAMT
    do Format-Number(#K1.GPDE_KU_KUGKKAMT,$K1.GPDE_KU_KUGKKAMT,'B99,999.99')
         if  #counter = 0
         let #counter = 1
         end-if
        do Format-Number(#counter,$counter,'B9999')
        do Print_KUG_line
        let #counter = #counter + 1
    !
    ! the headinginfo issue:
    ! when a change is detected, then the new values are already loaded into the variables,
    ! but the page is not yet printed.
    ! At this moment the heading is called and prints the values for the new row
    ! for the data of the old page.
    ! That is the reason why we need to keep the last-copies of all variables that are
    ! printed in the heading.
    !
    ! If we do not provide PAY_ENTITY as mandatory input, then we need to manage it too
    let $lastStammNummer = $KUG_Stammnummer
    let $hdr_KUG_Stammnummer = $lastStammNummer
    let $lastPeriodEnd = &K2.GPDE_AL_CPAY_ENDDT
    !
    let #lastRefund = #Refund
    let #hdrlastRefund = #lastRefund
    let #lastTgtReg  = #TgtReg
    let #hdrlastTgtReg  = #lastTgtReg
    let $lastQualiElg  = $QualiElg
    let $hdrQualiElg = $lastQualiElg
    do ConvertToComponents($K1.PRD_END_DT, $EndYear, $EffMth, $EffDay)
    !
    ! if we had a break, it was evaluated and is no longer valid
    let #makePageBreak = 0
    let #SplitSum = 0

from PS_GPDE_RP_KU1_WRK K2
,PS_NAMES NM2
WHERE NM2.EMPLID=K2.EMPLID
AND NM2.EFFDT=(SELECT MAX(NM3.EFFDT ) FROM PS_NAMES NM3
    WHERE NM3.EMPLID=NM2.EMPLID
    )
AND K2.PAY_ENTITY = $Ctl_PayEntity
AND K2.PROCESS_INSTANCE = #ReportProcessInstance
AND K2.GPDE_KU_KUGAMT <> 0
AND K2.GPDE_BL_TYPE IN ('B','C')
!no: AND K1.GPDE_AL_CPAY_ENDDT = $Ctl_Curr_Pay_End_DT
ORDER BY  K2.SEG_END_DT,K2.GPDE_KU_ID_NUM ASC,K2.GPDE_KU_QUALI_ELIG DESC ,K2.GPDE_KU_SI_REFUND  ASC, K2.GPDE_KU_TARGET_REG ASC,
NM2.NAME,K2.PRD_END_DT DESC,K2.GPDE_BL_TYPE
!--,K1.GPDE_AL_CPAY_ENDDT
End-Select

    !
    ! --- general cleanup ---
    !
    if #counter = 0
        show 'Es wurden keine Daten zu den Eingaben gefunden.'
    end-if
    !
    ! print the last footer, unless we have a new page
    !
    !
    if #eventFirstRow = 0
        let #eventStammNummer = 1             ! pending change of value to nothing
        do ManagePrintPageSum
        ! report totals here
    end-if

end-procedure





begin-procedure Print_Employee_Data
! main select here
    let #counter = 1        ! row counter per group
    let #currLineN = 0
    let #currLineV = 0
    let #TempCol = 1

    ! BREAK detection
    let $lastPeriodEnd = ' '
    let $lastStammNummer = '-none-'
    let $EndYear = ''
    let #makePageBreak = 0
    ! Sums
    let #pageSumKug = 0
    let #EntsolSum = 0
    let #EntistSum = 0
    !Target Region
    let #TgtReg = 9
    let #lastTgtReg  = 99
    ! Refund KUG SI Contribution
    let #Refund = 0
    let #lastRefund = 99
    ! Events
    let #eventStammNummer = 0           ! Change of Stammnummer coming up
    let #eventFirstRow = 1              ! First row of the page
    ! Print Sum Per Split
    let #SplitSum = 0
    let $QualiElg = ' '
    let $lastQualiElg = ' '
    let #i = 0
Begin-Select
K1.EMPLID
K1.CAL_RUN_ID
K1.EMPL_RCD
K1.GP_PAYGROUP
K1.CAL_ID
K1.ORIG_CAL_RUN_ID
K1.RSLT_SEG_NUM
K1.SEG_END_DT
K1.SLICE_END_DT
K1.GPDE_BL_TYPE
K1.PAY_ENTITY
K1.PRD_END_DT
K1.GPDE_AL_CPAY_ENDDT
K1.GPDE_KU_ID_NUM
K1.BGN_DT
K1.END_DT
K1.GPDE_DV_RVNR
K1.GPDE_KU_HKUGSUM
K1.GPDE_KU_HKGKK
K1.GPDE_KU_HKUGINS
K1.GPDE_KU_ENTSOLL
K1.GPDE_KU_ENTIST
K1.GPDE_TX_INC_TX_CLS
K1.GPDE_KU_BEN_GRP
K1.GPDE_KU_BEN_STP
K1.GPDE_KU_LSTSOLL
K1.GPDE_KU_LSTIST
K1.GPDE_KU_AVGLST
K1.GPDE_KU_KUGAMT
K1.GPDE_KU_NEBEN
K1.GPDE_KU_KUGKKAMT
NM1.NAME
NM1.LAST_NAME
NM1.FIRST_NAME
K1.GPDE_KU_QUALI_ELIG
K1.GPDE_KU_TARGET_REG
K1.GPDE_KU_SI_REFUND

    let #TgtReg = &K1.GPDE_KU_TARGET_REG
    let #Refund = &K1.GPDE_KU_SI_REFUND
    let $QualiElg = rtrim(&K1.GPDE_KU_QUALI_ELIG,' ')

    ! --- informational fields ---
    ! note: the #counter should only incremented when we really print a line

    let $RowType = &K1.GPDE_BL_TYPE
! Split the report on change in A.KUG_Stammnummer B. Refund  & C. TgtReg
    let $KUG_Stammnummer = rtrim(&K1.GPDE_KU_ID_NUM,' ')
    if ( $KUG_Stammnummer <> $lastStammNummer )
        #debug show 'force begin of a new page (KUG_Stammnummer)'
        let #makePageBreak = 1
        let #eventStammNummer = 1
        let #SplitSum = 1
        let #counter = 0
    end-if
    if  #lastRefund <> #Refund
        let #makePageBreak = 1
        let #eventStammNummer = 1
        let #SplitSum = 1
        let #counter = 0
    end-if
    if  #lastTgtReg <> #TgtReg
         let #makePageBreak = 1
         let #eventStammNummer = 1
         let #SplitSum = 1
         let #counter = 0
    end-if
    if  $lastQualiElg <> $QualiElg and $lastQualiElg <> ' '
        let #makePageBreak = 1
        let #SplitSum = 1
        let #eventStammNummer = 0
        let #counter = 0
     end-if

    let $K1.GPDE_DV_RVNR = &K1.GPDE_DV_RVNR
    let $Emplid = rtrim(&K1.EMPLID,' ')
    let $EmplRcd = &K1.EMPL_RCD

    let $K1.PRD_END_DT = &K1.PRD_END_DT
!    if ( $K1.PRD_END_DT <> $lastPeriodEnd )
!        #debug show 'force begin of a new page (K1.PRD_END_DT)'
!        let #makePageBreak = 1
!    end-if

    ! parameter for row-date output
    !--let $SegmentDate = &K1.GPDE_AL_CPAY_ENDDT
    let $SegmentDate = &K1.PRD_END_DT
    do MakeRowDate      ! returns: $RowDateText  in format: MM.YY neu/alt
    !----------------------------------------------------------------------
    do ConvertToComponents($Ctl_Curr_Pay_End_DT, $EffYear, $EffMth, $EffDay)       
    do Get_TaxFactor_data($Emplid,&K2.EMPL_RCD,$K1.PRD_END_DT,$EffYear,$gpde_tx_factor)
    do ConvertToComponents($K1.PRD_END_DT, $EndYear, $EffMth, $EffDay)
    !----------------------------------------------------------------------
    #debug show 'Progressinfo: ' $Emplid ' / ' $KUG_Stammnummer ' / ' $lastStammNummer ' - ' $hdr_KUG_Stammnummer

    let $NM1.NAME = rtrim(&NM1.NAME,' ')
    
! uncomment this if emplid should be printed
! #if debug
!    ! debug: add Emplid
!    let $NM1.NAME = $NM1.NAME || ',' || $Emplid
! #endif

    ! -- when name is printed in regular font we need to truncate at length 28
    if length($NM1.NAME) > 41
        let $NM1.NAME = substr($NM1.NAME,1,41)
    end-if

    let $K1.GPDE_TX_INC_TX_CLS = &K1.GPDE_TX_INC_TX_CLS
    let $K1.GPDE_KU_BEN_STP = &K1.GPDE_KU_BEN_STP
    let $K1.GPDE_KU_BEN_GRP = &K1.GPDE_KU_BEN_GRP

    ! --- numeric values ---
    ! --- HOURS ---
    ! notice, that we need 4 digits because we can have negative hours in retro
    let #K1.GPDE_KU_HKUGSUM = &K1.GPDE_KU_HKUGSUM
    do Format-Number(#K1.GPDE_KU_HKUGSUM,$K1.GPDE_KU_HKUGSUM,'B999.99')
    let #K1.GPDE_KU_HKGKK = &K1.GPDE_KU_HKGKK
    do Format-Number(#K1.GPDE_KU_HKGKK,$K1.GPDE_KU_HKGKK,'B999.99')
    let #K1.GPDE_KU_HKUGINS = &K1.GPDE_KU_HKUGINS
    do Format-Number(#K1.GPDE_KU_HKUGINS,$K1.GPDE_KU_HKUGINS,'B999.99')

    let #K1.GPDE_KU_ENTSOLL = &K1.GPDE_KU_ENTSOLL
    do Format-Number(#K1.GPDE_KU_ENTSOLL,$K1.GPDE_KU_ENTSOLL,'B99,999.99')
    let #K1.GPDE_KU_ENTIST = &K1.GPDE_KU_ENTIST
    do Format-Number(#K1.GPDE_KU_ENTIST,$K1.GPDE_KU_ENTIST,'B99,999.99')

    let #K1.GPDE_KU_LSTSOLL = &K1.GPDE_KU_LSTSOLL
    do Format-Number(#K1.GPDE_KU_LSTSOLL,$K1.GPDE_KU_LSTSOLL,'B99,999.99')
    let #K1.GPDE_KU_LSTIST = &K1.GPDE_KU_LSTIST
    do Format-Number(#K1.GPDE_KU_LSTIST,$K1.GPDE_KU_LSTIST,'B99,999.99')

    let #K1.GPDE_KU_AVGLST = &K1.GPDE_KU_AVGLST
    do Format-Number(#K1.GPDE_KU_AVGLST,$K1.GPDE_KU_AVGLST,'B999.99')

    let #K1.GPDE_KU_KUGAMT = &K1.GPDE_KU_KUGAMT
    do Format-Number(#K1.GPDE_KU_KUGAMT,$K1.GPDE_KU_KUGAMT,'B99,999.99')
    let #K1.GPDE_KU_KUGKKAMT = &K1.GPDE_KU_KUGKKAMT
    do Format-Number(#K1.GPDE_KU_KUGKKAMT,$K1.GPDE_KU_KUGKKAMT,'B99,999.99')
         if  #counter = 0
         let #counter = 1
         end-if
        do Format-Number(#counter,$counter,'B9999')
        do Print_KUG_line
        let #counter = #counter + 1
    !
    ! the headinginfo issue:
    ! when a change is detected, then the new values are already loaded into the variables,
    ! but the page is not yet printed.
    ! At this moment the heading is called and prints the values for the new row
    ! for the data of the old page.
    ! That is the reason why we need to keep the last-copies of all variables that are
    ! printed in the heading.
    !
    ! If we do not provide PAY_ENTITY as mandatory input, then we need to manage it too
    let $lastStammNummer = $KUG_Stammnummer
    let $hdr_KUG_Stammnummer = $lastStammNummer
    let $lastPeriodEnd = &K1.GPDE_AL_CPAY_ENDDT
    !
    let #lastRefund = #Refund
    let #hdrlastRefund = #lastRefund
    let #lastTgtReg  = #TgtReg
    let #hdrlastTgtReg  = #lastTgtReg
    let $lastQualiElg  = $QualiElg
    let $hdrQualiElg = $lastQualiElg

    !
    ! if we had a break, it was evaluated and is no longer valid
    let #makePageBreak = 0
    let #SplitSum = 0

from PS_GPDE_RP_KU1_WRK K1
,PS_NAMES NM1
WHERE NM1.EMPLID=K1.EMPLID
AND NM1.EFFDT=(SELECT MAX(NM2.EFFDT ) FROM PS_NAMES NM2
    WHERE NM2.EMPLID=NM1.EMPLID
    )
AND K1.PAY_ENTITY = $Ctl_PayEntity
AND K1.PROCESS_INSTANCE = #ReportProcessInstance
AND K1.GPDE_KU_KUGAMT <> 0
AND K1.GPDE_BL_TYPE NOT IN ('B','C')
!no: AND K1.GPDE_AL_CPAY_ENDDT = $Ctl_Curr_Pay_End_DT
ORDER BY  K1.GPDE_KU_ID_NUM ASC,K1.GPDE_KU_QUALI_ELIG DESC ,K1.GPDE_KU_SI_REFUND  ASC, K1.GPDE_KU_TARGET_REG ASC,
NM1.NAME,K1.PRD_END_DT DESC
!--,K1.GPDE_AL_CPAY_ENDDT
End-Select

    !
    ! --- general cleanup ---
    !
    if #counter = 0
        show 'Es wurden keine Daten zu den Eingaben gefunden.'
    end-if
    !
    ! print the last footer, unless we have a new page
    !
    !
    if #eventFirstRow = 0
        let #eventStammNummer = 1   ! pending change of value to nothing
        do ManagePrintPageSum
        ! report totals here
    end-if

end-procedure Print_Employee_Data





begin-procedure Print_KUG_line

   If #i = 1 Or ($PrevDate <> $RowSegDate And $RowSegDate <> ' ')
    Let #eventFirstRow = 1
    If $PrevDate <> ' '
        do ManagePrintPageSum
    End-If
    New-Page
    let #i=0
  End-If

    ! print KUG line
    ! prepare the check for a new page because the page was full
    let #mm = 4 + #current-line
      ! check if we need a new page because of data content
    if #makePageBreak > 0
        ! page break needed because of a datachange
        ! we only do it when this is NOT the first row on the page
        if #eventFirstRow = 0
            ! we have a functional BREAK
            ! trick to force a new page: simulate we have printed enough for the page
            let #mm = 1000
        end-if
    end-if

    if #mm > 50
        ! we need a new page because the page is full
        ! We need sum only after split.
        if #SplitSum = 1
            do ManagePrintPageSum
        let #SplitSum = 0
        end-if
        new-page
!adj10-print Matrix when a change is detected         
    if ( ( $KUG_Stammnummer <> $lastStammNummer ) OR ( #lastRefund <> #Refund ) OR ( #lastTgtReg <> #TgtReg )
        OR ( $lastQualiElg <> $QualiElg) or (#page-count = 1) )
 !        print-image gpdeku01 (-9,168)  
        print-image (-9,168)
        
      Type = JPEG-FILE
      image-size = (12,6) ! 1.61cms on A4
      source = $FileDir  
      
          alter-printer
          font= 4
          point-size = 15 
         print '3'  (-3,182)
         alter-printer
         font= 4
         point-size =13         
    END-IF         
        #debug show 'new page at emplid=' $Emplid 
        let #eventFirstRow = 1
    end-if


    ! some line arithmetics
    let #currLineV = -10 + #current-line
    let #currLineN = #currLineV + 1
    if #currLineV <= 0
        let #currLineV = 1
        let #currLineN = 2
    end-if

    if #eventFirstRow > 0
        ! we have hit an empty page body, paint the column headings
        let #eventFirstRow = 0
        do bodybox
        let #currLineN = #currLineN + 8
        let #currLineV = #currLineV + 8
        let #TempCol = #TempCol + 6
    end-if

    let #TempCol = 1 + #currLineV
    graphic (#currLineN,1,184) box 3 1
    graphic (#currLineV,#vline1,3) vert-line 1

    graphic (#currLineV,#vline2,3) vert-line 1
    graphic (#currLineV,#vline4,3) vert-line 1          ! after hours
    graphic (#currLineV,#vline5,3) vert-line 1
    graphic (#currLineV,#vline6,3) vert-line 1
    graphic (#currLineV,#vline7,3) vert-line 1         ! after Stkl

    graphic (#currLineV,#vline8,3) vert-line 1
    graphic (#currLineV,#vline9,3) vert-line 1
    graphic (#currLineV,#vline10,3) vert-line 1
    graphic (#currLineV,#vline11,3) vert-line 1

    alter-printer
    font = 3
    point-size = 16
    !  ---  Line#1  ---
    print $counter                (#TempCol,2)
    !print $RowDateText            (#TempCol,+3)  ! 9 chars
    ! -- name in smaller font
    alter-printer
    font = 4
    point-size = 12
    print $NM1.NAME               (#TempCol,+3)
    alter-printer
    font = 3
    point-size = 16

    print 'Kug:'                  (#TempCol,46)
    print $K1.GPDE_KU_HKUGSUM     (#TempCol,51)

    print $K1.GPDE_KU_ENTSOLL     (#TempCol,+26)
    print $K1.GPDE_KU_ENTIST     (#TempCol,+9)

    print $K1.GPDE_KU_BEN_GRP     (#TempCol,+7) !col 6
    print '/'                     (#TempCol,+1)
    print $K1.GPDE_KU_BEN_STP     (#TempCol,+1)
    print ' '                     (#TempCol,+1)

    print $K1.GPDE_KU_LSTSOLL     (#TempCol,127) ! col 7
    print $K1.GPDE_KU_LSTIST      (#TempCol,141)

    print $K1.GPDE_KU_AVGLST      (#TempCol,155)
    print $K1.GPDE_KU_KUGAMT      (#TempCol,171)

    ! ----  Line#2  ----
    let #TempCol = 1 + #TempCol

    ! -- VSNR also in smaller font (like name)
!    alter-printer
!    font = 3
!    point-size = 12
    print 'VSNR: '                (#TempCol,10)
    print $K1.GPDE_DV_RVNR        (#TempCol,+1)
    print 'Ins:'                  (#TempCol,63)
    print $K1.GPDE_KU_HKUGINS     (#TempCol,68)
    ! ----  Line#3  ----
    let #TempCol = 1 + #TempCol
    alter-printer
    font = 3
    point-size = 12
    if $GPDE_TX_FACTOR <> ''
     print 'Faktor: '               (#TempCol ,10)
    end-if
    print $GPDE_TX_FACTOR          (#TempCol,17)  edit  B9.999
    print $RowDateText             (#TempCol,33)
    alter-printer
    font = 3
    point-size = 16
    print 'KrG:'                   (#TempCol,46)
    print $K1.GPDE_KU_HKGKK        (#TempCol,51)

        !--- update the sums after the values were printed ---
    let #pageSumKug = #pageSumKug + #K1.GPDE_KU_KUGAMT
    let #EntsolSum =  #EntsolSum  + #K1.GPDE_KU_ENTSOLL
    let #EntistSum =  #EntistSum  + #K1.GPDE_KU_ENTIST
    ! clean up
    alter-printer
    font = 3
    point-size = 16

     NoPr2Kug:

           Let $PrevDate = $RowSegDate
end-procedure
!*************************************************************************************






begin-procedure ManagePrintPageSum
! print the page sum and update the total sum
! this is called BEFORE the current line is printed
!
#debug show 'ManagePrintPageSum'
    ! --- graphics for the Sums ---
    ! we reuse last used #TempCol
   ! let #TempCol = #TempCol + 1         ! add an empty line
    let #thisLine1 = #TempCol
    let #thisLine2 = #TempCol + 1
    let #tempw = #vline11 - #vline7

    graphic (#thisLine2,#vline2,66) box 2 1
    graphic (#thisLine2,1,184) box 5 1 1
    graphic (#TempCol,#vline2,5) vert-line 1
    graphic (#TempCol,#vline4,5) vert-line 1
    graphic (#TempCol,#vline5,5) vert-line 1
    graphic (#TempCol,#vline7,5) vert-line 1
    graphic (#TempCol,#vline11,5) vert-line 1

    let #TempCol = #TempCol + 1
    graphic (#TempCol,#vline6,4) vert-line 1
    ! switch font, typewriter: font=3   proportional: font=4
        alter-printer
        font = 4
        point-size = 13
        
!sps Taxupdate  2012 - Changes in KUG Reporting - Statrt
    !print '*)Die Summe der pauschalierten SV-Erstattung ist' (#TempCol,#txtpos0)
    !let #temp2 = #TempCol + 1
    !print 'nur auf der letzten Seite der Abrechnungsliste' (#temp2,#txtpos0)
    !print 'nur' (#temp2,#txtpos0)
    !graphic (#temp2,2,3) horz-line 10
    !let #temp2 = #temp2 + 1
    !print 'einzutragen.'  (#temp2,#txtpos0)
    !let #temp2 = #temp2 + 1
    !print 'Je Erstattungspauschale (50 oder 100 %) bitte eine'   (#temp2,#txtpos0)
    !let #temp2 = #temp2 + 1
    !let $tempvar = 'eigene Abrechnungsliste erstellen!!'
    !print $tempvar (#temp2,#txtpos0)
!sps Taxupdate  2012 - Changes in KUG Reporting - End
    print '         Summe'  (#TempCol,90)
    ! switch font, typewriter: font=3   proportional: font=4
    alter-printer
    font = 4
    point-size = 13
    print 'Summe Kug:'                (#TempCol,154)
    alter-printer
    font = 3
    point-size = 16

    do Format-Number(#pageSumKug,$pageSumKug,'B99,999,999.99')
    print $pageSumKug                  (#TempCol,165)
    let #TempCol = #TempCol + 1
    alter-printer
    font = 4
    point-size = 13
     print 'Spalte 4                     Spalte 5'  (#TempCol,86)
    graphic (#TempCol,#vline5,107) horz-line 10
    let #TempCol = #TempCol + 2
    do Format-Number(#EntsolSum,$EntsolSum,'B99,999,999.99')
    alter-printer
    font = 3
    point-size = 16
    print $EntsolSum     (#TempCol,79)
    do Format-Number(#EntistSum,$EntistSum,'B99,999,999.99')
    print $EntistSum     (#TempCol,98)
!sps Taxupdate  2012 - Changes in KUG Reporting - Statrt
! Update KUG Refund amount based on Refund Percentage
    !Let #Dif45 = ( #EntsolSum - #EntistSum ) * 0.8

    !if Current pay end date year >=2011 then
    !percentage is .195 for 50% and .390 for 100%
    
    !if $EndYear >= '2011'
    !   if #hdrlastRefund = 50
    !       Let #RefundAmt = #Dif45 * 0.195
    !   end-if
    !   if #hdrlastRefund = 100
    !       Let #RefundAmt = #Dif45 * 0.390
    !   end-if
    !else   
    !    if #hdrlastRefund = 50
    !         Let #RefundAmt = #Dif45 * 0.196
    !    end-if
    !    if #hdrlastRefund = 100
    !        Let #RefundAmt = #Dif45 * 0.392
    !    end-if    
    !end-if

    !if #hdrlastRefund = 0
    !   Let #RefundAmt = 0
    !end-if
    !do Format-Number(#RefundAmt,$RefundAmt,'B99,999,999.99')
    !alter-printer
    !font = 4
    !point-size = 13
    
    !print 'Summe pauschalierte SV-Erstattung'     (#TempCol,135)
!sps Taxupdate  2012 - Changes in KUG Reporting - End

    alter-printer
    font = 3
    point-size = 16
    !sps Taxupdate  2012 - Changes in KUG Reporting 
    !print $RefundAmt (#TempCol,165)
    let #TempCol = #TempCol + 2
    print 'Alle Beträge in Euro'       (#TempCol,1)
!!!!!!!
    let #pageSumKug = 0
    let #EntsolSum = 0
    let #EntistSum = 0
    let #RefundAmt = 0

    if  #eventStammNummer = 1
        let #eventStammNummer = 0
    end-if
end-procedure



! #############
! #############
! ############# UTILS
! #############
! #############
!**********************************************************************
begin-procedure Get_VersionNr
begin-select
VERS.GPDE_VERSION_NR
VERS.NAME
from PS_GPDE_VERSION VERS
end-select
let $VersionsNr = rtrim(&VERS.GPDE_VERSION_NR,' ')
let $Bezeichn   = rtrim(&VERS.NAME, ' ')
end-procedure
!**********************************************************************





!************************************************************************
begin-procedure Get-ReqParam
Begin-Select
RQ.PRCSINSTANCE
RQ.PRCSTYPE
RQ.PRCSNAME
RQ.RUNLOCATION
RQ.OPSYS
RQ.DBTYPE
RQ.DBNAME
RQ.OPRID
RQ.BEGINDTTM
RQ.ENDDTTM
RQ.RUNSTATUS
RQ.RUNCNTLID
RQ.OUTDESTTYPE
RQ.OUTDESTFORMAT
RQ.TIMEZONE
RQ.SERVERNAMERUN
! wdu jw2005--file handling
OD.PRCSOUTPUTDIR
OD.OUTDEST
FROM PSPRCSPARMS OD , PSPRCSRQST  RQ
WHERE OD.PRCSINSTANCE  = RQ.PRCSINSTANCE
AND   RQ.PRCSINSTANCE = #prcs_process_instance

End-Select
  let $OUTDEST       = rtrim(&OD.OUTDEST,' ')
  let $RQ.OUTDESTTYPE = rtrim(&RQ.OUTDESTTYPE,' ')
  let $RQ.OUTDESTFORMAT = rtrim(&RQ.OUTDESTFORMAT,' ')
  let $Process_Inst  = to_char(&RQ.PRCSINSTANCE)
! wdu jw2005--file handling
  move 'RUNLOCATION'  to $FieldName
  move &RQ.RUNLOCATION to $FieldValue
  do Read-Translate-Table
  let $RUNLOCATION = rtrim(ltrim($XlatlongName,' '),' ')

  move 'OUTDESTTYPE'  to $FieldName
  move &RQ.OUTDESTTYPE to $FieldValue
  do Read-Translate-Table
  let $OUTDESTTYPE = rtrim(ltrim($XlatlongName,' '),' ')
  move 'OUTDESTFORMAT'  to $FieldName
  move &RQ.OUTDESTFORMAT to $FieldValue
  do Read-Translate-Table
  let $OUTDESTFORMAT = rtrim(ltrim($XlatlongName,' '),' ')
  evaluate $RQ.OUTDESTFORMAT
  when = '1'
    let $OUTDESTFORM = 'PDF'
    break
  when = '2'
    let $OUTDESTFORM = 'PDF'
    break
  when = '3'
    let $OUTDESTFORM = 'CSV'
    break
  when = '4'
    let $OUTDESTFORM = 'HP'
    break
  when = '5'
    let $OUTDESTFORM = 'HTM'
    break
  when = '6'
    let $OUTDESTFORM = 'LP'
    break
  when = '7'
    let $OUTDESTFORM = 'WKS'
    break
  when = '8'
    let $OUTDESTFORM = 'XLS'
    break
  when = '9'
    let $OUTDESTFORM = 'DOC'
    break
  when = '10'
    let $OUTDESTFORM = 'PS'
    break
  when = '11'
    let $OUTDESTFORM = 'RPT'
    break
  when = '12'
    let $OUTDESTFORM = 'RTF'
    break
  when = '13'
    let $OUTDESTFORM = 'SPF'
    break
  when = '14'
    let $OUTDESTFORM = 'TXT'
    break
  when = '15'
    let $OUTDESTFORM = 'PDF'
    break
  when = '16'
    let $OUTDESTFORM = 'PDF'
    break
  when-other
    let $OUTDESTFORM = 'PDF'
    break
  end-evaluate
end-procedure





!****************************************************************************
Begin-Procedure Report-Translation
  do Get_Field_Information ('GPDEGLOB', 'EMPLID',        $HD_EMPLID, #CW)
  do Get_Field_Information ('GPDEGLOB', 'BIRTHDATE',     $HD_BIRTHDT,#CW)
  do Get_Field_Information ('GPDEGLOB', 'HIRE_DT',       $HD_HIREDT, #CW)
  do Get_Field_Information ('GPDEGLOB', 'TERMINATION_DT',$HD_TERMDT, #CW)
  do Get_Field_Information ('GPDEGLOB', 'PRINTCLASS',    $PRINTCLASS,#CW)
  do Get_Field_Information ('GPDEGLOB', 'AMOUNT_SPEC',         $AMOUNT_SPEC,#CW)
  do Get_Field_Information ('GPDEGLOB', 'EURO',        $EUROCHAR,     #CW)
end-Procedure



!****************************************************************************************
begin-procedure Get_Type_Options
let $Name_Type       = ''
let $Addr_Type       = ''
let $Phone_Type      = ''
let $Email_Type      = ''
let $BirthName_Type  = ''
begin-select distinct
INST.NAME_TYPE
INST.ADDRESS_TYPE
INST.PHONE_TYPE
INST.E_ADDR_TYPE
INST.GPDE_BIRTH_NM_TYPE
   let $Name_Type      = &INST.NAME_TYPE
   let $Addr_Type      = &INST.ADDRESS_TYPE
   let $Phone_Type     = &INST.PHONE_TYPE
   let $Email_Type     = &INST.E_ADDR_TYPE
   let $BirthName_Type = &INST.GPDE_BIRTH_NM_TYPE
from PS_GPDE_AL_INSTALL INST
end-select
end-procedure



begin-procedure CX_StandardHeaderBox
!
!  Print a standard Header Box for the Report GPDEKU01
!
#debug show 'CX_StandardHeaderBox Stamm=' $hdr_KUG_Stammnummer
! -- display $SeitenNr
    let $AMOUNT_SPEC1 = $AMOUNT_SPEC || ' ' || $sav_CurrencyA
    !do Get_Job_Position
    let $HD_Title1 = 'KUG Abrechnungsliste  ' || $HeaderDateString
    !let $HD_Title2 = 'Anlage zum Leistungsantrag'
    let $HD_Title2 = ' '

    alter-printer
    font= 4
    point-size =28
    print $HD_Title1        (1,1) bold

    alter-printer
    font= 4
    point-size =20
    print $HD_Title2        (3,1) bold

    alter-printer
    font= 4
    point-size =16

    !graphic (5,1,184) horz-line 10
    graphic (5,1,164) horz-line 10
    !(horizontal line was printed)
    ! --- right header block with date/pagenum/version ---
    alter-printer
    font= 4
    point-size =13

    print 'Seite :'               (1,132)
    print '['                     (1,140)
    if #page-count < 10
    print #page-count          (0,0) edit 9
    else
    print #page-count          (0,0) edit 99
    end-if
    print ']'                     (0,0)
    do Format-DateTime($AsOfToday, $hdr_abr_header_date, {DEFDATE}, '', '')
    print 'Datum :'               (2,132)
    print $hdr_abr_header_date    (2,140)
    !
    ! Version number
    let $Bemerk = $Bezeichn || ' ' || $VersionsNr
    print $Bemerk (3,132)
    ! --- employer address line below headline ---
    !
    let $HD_Firma = $hdr_abr_Payentity_name
    let $HD_Strasse = $hdr_abr_Payentity_street
    let $HD_Ort = $hdr_abr_Payentity_zip_city
    let $HD_BetrNr =  $GPDE_DO_BTNR
    !
    let $temp_str = rtrim($HD_Firma,' ') || ',  ' ||rtrim($HD_Strasse,' ') || ',  ' ||rtrim($HD_Ort,' ')
    ! print bigger
    alter-printer
    font= 4
    point-size =16
    print $temp_str          (5,1) bold

!adj10- draw line instead of box.
    !graphic (6,1,184) box 8 1 1
     graphic (5,1,8) vert-line 1   ! line at begining
     graphic (5,165,4) vert-line 1 ! line after the region 3
    ! ---
    print 'Kug-Abrechnungsliste-Anlage zum Leistungsantrag' (7,12) bold
    !sps Taxupdate  2012 - Changes in KUG Reporting - Statrt
    !graphic (8,2,2) box 1 1 1
    !print 'pauschalierte SV-Erstattung 50%' (8,5) bold
    !graphic (8,51,2) box 1 1 1
    !print 'pauschalierte SV-Erstattung 100%' (8,54) bold
    !print '(Bitte reichen Sie je Erstattungspauschale eine gesonderte Abrechnungsliste ein.)' (9,2)

    !if #hdrlastRefund = 50
    ! print 'X' (8,2) bold
    !end-if
    !if  #hdrlastRefund = 100
    ! print 'X' (8,51) bold
    !end-if
    !sps Taxupdate  2012 - Changes in KUG Reporting - End
    
    graphic (5,98,4) vert-line 1
    print 'Kug-Stammnummer'    (7,103) bold
    print $hdr_KUG_Stammnummer      (7,130) bold

!adj10-Matrix code is always printed on first page.
    if #page-count = 1
!       print-image gpdeku01 (-5,168)        
        print-image (-5,168)
        
      Type = JPEG-FILE
      image-size = (12,6) ! 1.61cms on A4
      source = $FileDir        
      
          alter-printer
          font= 4
          point-size =15 
       print '3'  (8,182) 
          alter-printer
          font= 4
          point-size =16       
    end-if
    
!sps Taxupdate  2012 - Changes in KUG Reporting - Start       
! Print Region
    !graphic (12,103,2) box 1 1 1
    !print 'Zielgebiet 1 ' (12,106) bold
    !graphic (12,130,2) box 1 1 1
    !print 'Zielgebiet 2 ' (12,133) bold
    !graphic (12,153,2) box 1 1 1
    !print 'Übergangsgebiet' (12,156) bold

    !if #hdrlastTgtReg = 1 AND $hdrQualiElg = 'Y'
    ! print 'X' (12,103) bold
    !end-if
    !if #hdrlastTgtReg = 2 AND $hdrQualiElg = 'Y'
    ! print 'X' (12,130) bold
    !end-if
    !if #hdrlastTgtReg = 3 AND $hdrQualiElg = 'Y'
    ! print 'X'  (12,153) bold
    !end-if
!sps Taxupdate  2012 - Changes in KUG Reporting - End

!adj10-reduced 2nd hoz line
 !  graphic (9,1,164) horz-line 10  
    graphic (9,1,184) horz-line 10  
!adj10-draw vertline at end
  graphic (9,185,4) vert-line 1      

    !sps Taxupdate  2012 - Changes in KUG Reporting - Start
    !print 'Bei ESF-geförderter Qualifizierungsmaßnahme bitte den zutreffenden Bereich ankreuzen:' (11,1) bold
    !print '(Bitte reichen Sie für jeden Bereich eine gesonderte Abrechnungsliste ein.)' (12,1)
    !Taxupdate  2013 - Changes in KUG Reporting
    !graphic (11,2,2) box 1 1 1

    If $hdrQualiElg = 'Y'
     print 'X' (11,2) bold
    end-if
    !Taxupdate  2013 - Changes in KUG Reporting
    !print 'Abrechnungsliste für Arbeitnehmer, die an ESF-geförderten Qualifizierungsmaßnahmen teilgenommen haben' (11,6) bold
    !print '(nur für Abrechnungszeiträume bis einschließlich September 2012).' (12,6)

    !sps Taxupdate  2012 - Changes in KUG Reporting - End
    ! ---
    !switch back font
    alter-printer
    font= 4
    point-size =13
end-procedure






begin-procedure Get-PayEntity-Data($payentity, $curr_pay_end_dt, :$PayentityName,
                :$PayentityStreet,:$PayentityStreet2,:$PayentityStreet2,:$PoBox,
                :$PayentityZipCity,:$Nation,:$Post,:$Cit)
let $PayentityName    = ' '
let $PayentityStreet  = ' '
let $PayentityStreet2 = ' '
let $PayentityStreet3 = ' '
let $PoBox = ' '
let $PayentityZipCity = ' '
let $Nation = ' '
let $Post = ' '
let $Cit = ' '
begin-SELECT
CP.DESCR
CT.ADDRESS1
CT.ADDRESS2
CT.ADDRESS3
CT.ADDRESS4
CT.CITY
CT.POSTAL
CT.COUNTRY
  let $PayentityName = rtrim(&CP.DESCR,' ')
  let $PayentityStreet = rtrim(&CT.ADDRESS1,' ')
  let $PayentityStreet2 = rtrim(&CT.ADDRESS2,' ')
  let $PayentityStreet3 = rtrim(&CT.ADDRESS3,' ')
  let $PoBox = rtrim(&CT.ADDRESS4,' ')
  let $Nation = rtrim(&CT.COUNTRY,' ')
  let $Post = rtrim(&CT.POSTAL,' ')
  let $Cit = rtrim(&CT.CITY,' ')
  let $PayentityZipCity = rtrim(&CT.POSTAL,' ') || ' ' || rtrim(&CT.CITY,' ')
FROM  PS_GP_PYENT CP, PS_GP_PYENT_DTL CT
WHERE CP.PAY_ENTITY = CT.PAY_ENTITY
AND   CP.PAY_ENTITY = $payentity
AND   CT.EFFDT = (SELECT MAX(EFFDT) FROM   PS_GP_PYENT_DTL CT1
      WHERE  CT1.PAY_ENTITY = CT.PAY_ENTITY AND  CT1.EFFDT  <= $curr_pay_end_dt)
end-SELECT
end-procedure


begin-procedure get-values
! a callback from some sqc, do not remove
end-procedure





begin-procedure PrepareRowData
! prepare the current('C') and before('B') rows from the WA
!
show 'processing data for :' $Ctl_Curr_Pay_End_DT

! We need KUG information for the current calculation and the version before that
! for each CAL_ID which was handled (retro+current) in the current calculation.
!
! We may not have rows in GPDE_RP_KU01 for both periods, so we need another
! record as driver table (GPDE_RP_0001)
!
do CreateRowDriver

begin-sql
DELETE FROM PS_GPDE_RP_KU1_WRK  WHERE PROCESS_INSTANCE = #ReportProcessInstance
end-sql


! ------------ get current calculation data including retro as 'C'
! 'N' is similar to 'C' but means, that no old version exists

begin-sql
INSERT INTO PS_GPDE_RP_KU1_WRK (
PROCESS_INSTANCE,
EMPLID,
CAL_RUN_ID,
EMPL_RCD,
GP_PAYGROUP,
CAL_ID,
ORIG_CAL_RUN_ID,
RSLT_SEG_NUM,
SEG_END_DT,
SLICE_END_DT,
GPDE_BL_TYPE,
PAY_ENTITY,
PRD_END_DT,
GPDE_AL_CPAY_ENDDT,
GPDE_KU_ID_NUM,
BGN_DT,
END_DT,
GPDE_DV_RVNR,
GPDE_KU_HKUGSUM,
GPDE_KU_HKGKK,
GPDE_KU_HKUGINS,
GPDE_KU_ENTSOLL,
GPDE_KU_ENTIST,
GPDE_TX_INC_TX_CLS,
GPDE_KU_BEN_GRP,
GPDE_KU_BEN_STP,
GPDE_KU_LSTSOLL,
GPDE_KU_LSTIST,
GPDE_KU_AVGLST,
GPDE_KU_KUGAMT,
GPDE_KU_KUGKKAMT,
GPDE_KU_NEBEN,
GPDE_SI_PROV_MAND,
GPDE_KU_QUALI_ELIG,
GPDE_KU_SI_REFUND,
GPDE_KU_TARGET_REG
)
SELECT
D1.PROCESS_INSTANCE,
K1.EMPLID,
K1.CAL_RUN_ID,
K1.EMPL_RCD,
K1.GP_PAYGROUP,
K1.CAL_ID,
K1.ORIG_CAL_RUN_ID,
K1.RSLT_SEG_NUM,
K1.SEG_END_DT,
K1.SLICE_END_DT,
D1.GPDE_BL_TYPE,
K1.PAY_ENTITY,
K1.PRD_END_DT,
K1.GPDE_AL_CPAY_ENDDT,
K1.GPDE_KU_ID_NUM,
K1.BGN_DT,
K1.END_DT,
K1.GPDE_DV_RVNR,
K1.GPDE_KU_HKUGSUM,
K1.GPDE_KU_HKGKK,
K1.GPDE_KU_HKUGINS,
K1.GPDE_KU_ENTSOLL,
K1.GPDE_KU_ENTIST,
K1.GPDE_TX_INC_TX_CLS,
K1.GPDE_KU_BEN_GRP,
K1.GPDE_KU_BEN_STP,
K1.GPDE_KU_LSTSOLL,
K1.GPDE_KU_LSTIST,
K1.GPDE_KU_AVGLST,
K1.GPDE_KU_KUGAMT,
K1.GPDE_KU_KUGKKAMT,
K1.GPDE_KU_NEBEN,
K1.GPDE_SI_PROV_MAND,
K1.GPDE_KU_QUALI_ELIG,
K1.GPDE_KU_SI_REFUND,
K1.GPDE_KU_TARGET_REG
FROM PS_GPDE_RP_KU01 K1
,PS_GPDE_RP_KU_DRV D1
WHERE K1.PAY_ENTITY = $Ctl_PayEntity
AND K1.EMPLID = D1.EMPLID
AND K1.CAL_RUN_ID = D1.CAL_RUN_ID
AND K1.EMPL_RCD = D1.EMPL_RCD
AND K1.GP_PAYGROUP = D1.GP_PAYGROUP
AND K1.CAL_ID = D1.CAL_ID
AND K1.ORIG_CAL_RUN_ID = D1.ORIG_CAL_RUN_ID
! no: --AND K1.RSLT_SEG_NUM = D1.RSLT_SEG_NUM
AND K1.SEG_END_DT = D1.SEG_END_DT
AND K1.PRD_END_DT = D1.PRD_END_DT
AND K1.PAY_ENTITY = D1.PAY_ENTITY
AND K1.GPDE_AL_CPAY_ENDDT = D1.GPDE_AL_CPAY_ENDDT
AND D1.GPDE_BL_TYPE IN  ('C','N')
AND D1.PROCESS_INSTANCE = #ReportProcessInstance
end-sql



! ------------ get previous (=before) row for each current calculation row as 'B'

begin-sql
INSERT INTO PS_GPDE_RP_KU1_WRK (
PROCESS_INSTANCE,
EMPLID,
CAL_RUN_ID,
EMPL_RCD,
GP_PAYGROUP,
CAL_ID,
ORIG_CAL_RUN_ID,
RSLT_SEG_NUM,
SEG_END_DT,
SLICE_END_DT,
GPDE_BL_TYPE,
PAY_ENTITY,
PRD_END_DT,
GPDE_AL_CPAY_ENDDT,
GPDE_KU_ID_NUM,
BGN_DT,
END_DT,
GPDE_DV_RVNR,
GPDE_KU_HKUGSUM,
GPDE_KU_HKGKK,
GPDE_KU_HKUGINS,
GPDE_KU_ENTSOLL,
GPDE_KU_ENTIST,
GPDE_TX_INC_TX_CLS,
GPDE_KU_BEN_GRP,
GPDE_KU_BEN_STP,
GPDE_KU_LSTSOLL,
GPDE_KU_LSTIST,
GPDE_KU_AVGLST,
GPDE_KU_KUGAMT,
GPDE_KU_KUGKKAMT,
GPDE_KU_NEBEN,
GPDE_SI_PROV_MAND,
GPDE_KU_QUALI_ELIG,
GPDE_KU_SI_REFUND,
GPDE_KU_TARGET_REG
)
SELECT
D1.PROCESS_INSTANCE,
K1.EMPLID,
K1.CAL_RUN_ID,
K1.EMPL_RCD,
K1.GP_PAYGROUP,
K1.CAL_ID,
K1.ORIG_CAL_RUN_ID,
K1.RSLT_SEG_NUM,
K1.SEG_END_DT,
K1.SLICE_END_DT,
D1.GPDE_BL_TYPE,
K1.PAY_ENTITY,
K1.PRD_END_DT,
K1.GPDE_AL_CPAY_ENDDT,
K1.GPDE_KU_ID_NUM,
K1.BGN_DT,
K1.END_DT,
K1.GPDE_DV_RVNR,
-K1.GPDE_KU_HKUGSUM,
-K1.GPDE_KU_HKGKK,
-K1.GPDE_KU_HKUGINS,
-K1.GPDE_KU_ENTSOLL,
-K1.GPDE_KU_ENTIST,
K1.GPDE_TX_INC_TX_CLS,
K1.GPDE_KU_BEN_GRP,
K1.GPDE_KU_BEN_STP,
-K1.GPDE_KU_LSTSOLL,
-K1.GPDE_KU_LSTIST,
-K1.GPDE_KU_AVGLST,
-K1.GPDE_KU_KUGAMT,
-K1.GPDE_KU_KUGKKAMT,
-K1.GPDE_KU_NEBEN,
K1.GPDE_SI_PROV_MAND,
K1.GPDE_KU_QUALI_ELIG,
K1.GPDE_KU_SI_REFUND,
K1.GPDE_KU_TARGET_REG
FROM PS_GPDE_RP_KU01 K1
,PS_GPDE_RP_KU_DRV D1
WHERE K1.PAY_ENTITY = $Ctl_PayEntity
AND K1.EMPLID = D1.EMPLID
AND K1.CAL_RUN_ID = D1.CAL_RUN_ID
AND K1.EMPL_RCD = D1.EMPL_RCD
AND K1.GP_PAYGROUP = D1.GP_PAYGROUP
AND K1.CAL_ID = D1.CAL_ID
AND K1.ORIG_CAL_RUN_ID = D1.ORIG_CAL_RUN_ID
! no: --AND K1.RSLT_SEG_NUM = D1.RSLT_SEG_NUM
AND K1.SEG_END_DT = D1.SEG_END_DT
AND K1.PRD_END_DT = D1.PRD_END_DT
AND K1.PAY_ENTITY = D1.PAY_ENTITY
AND K1.GPDE_AL_CPAY_ENDDT = D1.GPDE_AL_CPAY_ENDDT
AND D1.GPDE_BL_TYPE = 'B'
AND D1.PROCESS_INSTANCE = #ReportProcessInstance
end-sql

end-procedure




begin-procedure MakeRowDate
! in:  $SegmentDate
! out: $RowSegDate      date in the format:  mm.yy
! out: $RowTypeInd      an indicator for old/new/-
! out: $RowDateText     date + indicator
!
   let #Date_Type1 = {DateType}
   do ConvertToComponents($SegmentDate,$yy1a,$mm1a,$dd1a)
   evaluate #Date_Type1
   when = 2
      let $RowSegDate = $yy1a || '{PTDateDelim}' || $mm1a
      break
   when-other
      let $RowSegDate = $mm1a || '{PTDateDelim}' || $yy1a
      break
   end-evaluate

   if $RowType = 'B'
        let $RowTypeInd = ' alt'
   else
        if $RowType = 'C'
            let $RowTypeInd = ' neu'
        else
            ! for 'N' do not print indicator and date
            let $RowTypeInd = '    '
            let $RowSegDate = ' '
        end-if
   end-if

   let $RowDateText = $RowSegDate || $RowTypeInd
end-procedure





begin-procedure CreateRowDriver
!-------------------------------------------------------
! NOTICE: the driver is generic (does not depend on KUG)
! it can be copied and reused for all delta reports.
!-------------------------------------------------------
! create a helper table with a row for the current and previous calculation.
! we will use this later to find our rows from the KUG WA table
!
! GPDE_BL_TYPE
! 'C'   current calculation
! 'B'   before current calculation
! 'R'   raw data, discarded later
! 'N'   current calculation with no previous data
!
!
begin-sql
DELETE FROM PS_GPDE_RP_KU_DRV WHERE PROCESS_INSTANCE = #ReportProcessInstance
end-sql

! Find the current and the previous version for each calculation period
! -- when the emplid ever had KUG in our PAY-entity
! ==> raw driver
begin-sql
INSERT INTO PS_GPDE_RP_KU_DRV (
 PROCESS_INSTANCE
 ,EMPLID
 ,CAL_RUN_ID
 ,EMPL_RCD
 ,GP_PAYGROUP
 ,CAL_ID
 ,ORIG_CAL_RUN_ID
 ,RSLT_SEG_NUM
 ,SEG_END_DT
 ,PRD_END_DT
 ,PAY_ENTITY
 ,GPDE_AL_CPAY_ENDDT
 ,GPDE_BL_TYPE
)
SELECT
 #ReportProcessInstance
 ,A.EMPLID
 ,A.CAL_RUN_ID
 ,A.EMPL_RCD
 ,A.GP_PAYGROUP
 ,A.CAL_ID
 ,A.ORIG_CAL_RUN_ID
 ,A.RSLT_SEG_NUM
 ,A.SEG_END_DT
 ,A.PRD_END_DT
 ,A.PAY_ENTITY
 ,A.GPDE_AL_CPAY_ENDDT
 ,'R'
  FROM PS_GPDE_RP_0001 A
where A.PAY_ENTITY = $Ctl_PayEntity
AND (A.GPDE_AL_CPAY_ENDDT = (SELECT MAX(A2.GPDE_AL_CPAY_ENDDT)
      from PS_GPDE_RP_0001 A2
      WHERE A2.EMPLID = A.EMPLID
        !no: AND A2.CAL_RUN_ID = A.CAL_RUN_ID
        AND A2.EMPL_RCD = A.EMPL_RCD
        !no: AND A2.GP_PAYGROUP = A.GP_PAYGROUP
        AND A2.CAL_ID = A.CAL_ID
        AND A2.GPDE_AL_CPAY_ENDDT < $Ctl_Curr_Pay_End_DT
    )
    OR A.GPDE_AL_CPAY_ENDDT = $Ctl_Curr_Pay_End_DT
)
AND A.EMPLID IN (SELECT DISTINCT EMPLID FROM PS_GPDE_RP_KU01 WHERE PAY_ENTITY=$Ctl_PayEntity)
end-sql

! mark rows from the current calculation
! these will always be printed if a KUG WA row exists.
begin-sql
UPDATE PS_GPDE_RP_KU_DRV SET GPDE_BL_TYPE='C'
WHERE GPDE_AL_CPAY_ENDDT = $Ctl_Curr_Pay_End_DT
AND PROCESS_INSTANCE = #ReportProcessInstance
end-sql


! mark rows from previous periods only when:
!   -- a row exists for the same calendar which is marked 'C'
!
begin-sql
UPDATE PS_GPDE_RP_KU_DRV SET GPDE_BL_TYPE='B'
WHERE EXISTS (
    SELECT 'X' FROM PS_GPDE_RP_KU_DRV DRV2
    WHERE 0=0
        AND DRV2.EMPLID = PS_GPDE_RP_KU_DRV.EMPLID
!no:    AND DRV2.CAL_RUN_ID = PS_GPDE_RP_KU_DRV.CAL_RUN_ID
        AND DRV2.EMPL_RCD = PS_GPDE_RP_KU_DRV.EMPL_RCD
!no:    AND DRV2.GP_PAYGROUP = PS_GPDE_RP_KU_DRV.GP_PAYGROUP
        AND DRV2.CAL_ID = PS_GPDE_RP_KU_DRV.CAL_ID
!no:     AND DRV2.ORIG_CAL_RUN_ID = PS_GPDE_RP_KU_DRV.ORIG_CAL_RUN_ID
!no:     AND DRV2.RSLT_SEG_NUM = PS_GPDE_RP_KU_DRV.RSLT_SEG_NUM
!no:     AND DRV2.SEG_END_DT = PS_GPDE_RP_KU_DRV.SEG_END_DT
        AND DRV2.PRD_END_DT = PS_GPDE_RP_KU_DRV.PRD_END_DT
        AND DRV2.PAY_ENTITY = PS_GPDE_RP_KU_DRV.PAY_ENTITY
!no:     AND DRV2.GPDE_AL_CPAY_ENDDT = PS_GPDE_RP_KU_DRV.GPDE_AL_CPAY_ENDDT
        AND DRV2.GPDE_BL_TYPE = 'C'
        AND DRV2.PROCESS_INSTANCE = #ReportProcessInstance
)
AND GPDE_BL_TYPE='R'
AND PROCESS_INSTANCE = #ReportProcessInstance
end-sql

! Mark rows which are new and have no corresponding old row
! these should be printed without "neu" label
!
begin-sql
UPDATE PS_GPDE_RP_KU_DRV SET GPDE_BL_TYPE='N'
WHERE NOT EXISTS (
    SELECT 'X' FROM PS_GPDE_RP_KU_DRV DRV2
    WHERE 0=0
        AND DRV2.EMPLID = PS_GPDE_RP_KU_DRV.EMPLID
!no:    AND DRV2.CAL_RUN_ID = PS_GPDE_RP_KU_DRV.CAL_RUN_ID
        AND DRV2.EMPL_RCD = PS_GPDE_RP_KU_DRV.EMPL_RCD
!no:    AND DRV2.GP_PAYGROUP = PS_GPDE_RP_KU_DRV.GP_PAYGROUP
        AND DRV2.CAL_ID = PS_GPDE_RP_KU_DRV.CAL_ID
!no:     AND DRV2.ORIG_CAL_RUN_ID = PS_GPDE_RP_KU_DRV.ORIG_CAL_RUN_ID
!no:     AND DRV2.RSLT_SEG_NUM = PS_GPDE_RP_KU_DRV.RSLT_SEG_NUM
!no:     AND DRV2.SEG_END_DT = PS_GPDE_RP_KU_DRV.SEG_END_DT
        AND DRV2.PRD_END_DT = PS_GPDE_RP_KU_DRV.PRD_END_DT
        AND DRV2.PAY_ENTITY = PS_GPDE_RP_KU_DRV.PAY_ENTITY
!no:     AND DRV2.GPDE_AL_CPAY_ENDDT = PS_GPDE_RP_KU_DRV.GPDE_AL_CPAY_ENDDT
        AND DRV2.GPDE_BL_TYPE = 'B'
        AND DRV2.PROCESS_INSTANCE = #ReportProcessInstance
)
AND GPDE_BL_TYPE='C'
AND PROCESS_INSTANCE = #ReportProcessInstance
end-sql

end-procedure






begin-procedure getHeaderDateString
!
!
  do ConvertToComponents($Ctl_Curr_Pay_End_DT,$HD_yy,$HD_mm,$HD_dd)

  evaluate $HD_mm
    when = '01'
      let $HD_Month_Name = 'Januar'
      break
    when = '02'
      let $HD_Month_Name = 'Februar'
      break
    when = '03'
      let $HD_Month_Name = 'März'
      break
    when = '04'
      let $HD_Month_Name = 'April'
      break
    when = '05'
      let $HD_Month_Name = 'Mai'
      break
    when = '06'
      let $HD_Month_Name = 'Juni'
      break
    when = '07'
      let $HD_Month_Name = 'Juli'
      break
    when = '08'
      let $HD_Month_Name = 'August'
      break
    when = '09'
      let $HD_Month_Name = 'September'
      break
    when = '10'
      let $HD_Month_Name = 'Oktober'
      break
    when = '11'
      let $HD_Month_Name = 'November'
      break
    when = '12'
      let $HD_Month_Name = 'Dezember'
      break
    when-other
      let $HD_Month_Name = 'XXXXXXX'
      break
  end-evaluate

  let $HeaderDateString = $HD_Month_Name || ' ' || $HD_yy

  #DEBUG show 'Month Name = ' $HD_Month_Name
  #DEBUG show  '$HD_mm = ' $HD_mm
end-procedure


!*************************************************************************
#include 'number.sqc'    !routines to format numbers
!#include 'gpdetx03.sqc'  !get run control parameter values
#include 'gpdeut01.sqc'  !sqr strings table procedures
#include 'gpdeut03.sqc'  !get ask report parameters
#include 'gpdeut02.sqc'  !get ask report parameters
#include 'gpdeut04.sqc'  !get pay entity data
!#include 'gpdeut05.sqc'  !get employee address
#include 'gpdeut06.sqc'  !get run control parameter values
#include 'gpdeut07.sqc'  !get run control parameter values
#include 'curdttim.sqc'  !get-current-datetime procedure
#include 'datemath.sqc'  !function for date-calculation
#include 'validdt.sqc'   !validate date routine
#include 'readxlat.sqc'  !read-translate-table procedure
#include 'datetime.sqc'  !routines for date and time formatting
#include 'stdapi.sqc'    !routines to update run status
#include 'sqrtrans.sqc'  !sqr strings table procedures
!#include 'timemath.sqc'